// DO NOT EDIT: generated by fsdgenjs
/* eslint-disable */

import { FastifyPluginAsync } from 'fastify';
import { IServiceResult, IServiceError } from 'facility-core';

const standardErrorCodes: { [code: string]: number } = {
  'NotModified': 304,
  'InvalidRequest': 400,
  'NotAuthenticated': 401,
  'NotAuthorized': 403,
  'NotFound': 404,
  'Conflict': 409,
  'RequestTooLarge': 413,
  'TooManyRequests': 429,
  'InternalError': 500,
  'ServiceUnavailable': 503,
  'NotAdmin': 403,
  'TooHappy': 500,
};

function parseBoolean(value: string | undefined) {
  if (typeof value === 'string') {
    const lowerValue = value.toLowerCase();
    if (lowerValue === 'true') {
      return true;
    }
    if (lowerValue === 'false') {
      return false;
    }
  }
  return undefined;
}

export type ConformanceApiPluginOptions = {
  api: IConformanceApi;
}

export const conformanceApiPlugin: FastifyPluginAsync<ConformanceApiPluginOptions> = async (fastify, opts) => {
  const { api } = opts;

  fastify.route({
    url: '/',
    method: 'GET',
    handler: async function (req, res) {
      const request: IGetApiInfoRequest = {};

      const result = await api.getApiInfo(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200).send(result.value);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/widgets',
    method: 'GET',
    handler: async function (req, res) {
      const request: IGetWidgetsRequest = {};

      const query = req.query as Record<string, string>;
      if (typeof query['q'] === 'string') request.query = query['q'];

      const result = await api.getWidgets(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200).send(result.value);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/widgets',
    method: 'POST',
    handler: async function (req, res) {
      const request: ICreateWidgetRequest = {};

      request.widget = req.body as never;

      const result = await api.createWidget(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.url != null) res.header('Location', result.value.url);
        if (result.value.eTag != null) res.header('eTag', result.value.eTag);

        if (result.value.widget) {
          res.status(201).send(result.value.widget);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/widgets/:id',
    method: 'GET',
    handler: async function (req, res) {
      const request: IGetWidgetRequest = {};

      const params = req.params as Record<string, string>;
      if (typeof params['id'] === 'string') request.id = parseInt(params['id'], 10);

      const headers = req.headers as Record<string, string>;
      if (typeof headers['if-none-match'] === 'string') request.ifNotETag = headers['if-none-match'];

      const result = await api.getWidget(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.eTag != null) res.header('eTag', result.value.eTag);

        if (result.value.widget) {
          res.status(200).send(result.value.widget);
          return;
        }

        if (result.value.notModified) {
          res.status(304);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/widgets/:id',
    method: 'DELETE',
    handler: async function (req, res) {
      const request: IDeleteWidgetRequest = {};

      const params = req.params as Record<string, string>;
      if (typeof params['id'] === 'string') request.id = parseInt(params['id'], 10);

      const headers = req.headers as Record<string, string>;
      if (typeof headers['if-match'] === 'string') request.ifETag = headers['if-match'];

      const result = await api.deleteWidget(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.notFound) {
          res.status(404);
          return;
        }

        if (result.value.conflict) {
          res.status(409);
          return;
        }

        res.status(204);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/widgets/get',
    method: 'POST',
    handler: async function (req, res) {
      const request: IGetWidgetBatchRequest = {};

      request.ids = req.body as never;

      const result = await api.getWidgetBatch(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.results) {
          res.status(200).send(result.value.results);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/mirrorFields',
    method: 'POST',
    handler: async function (req, res) {
      const request: IMirrorFieldsRequest = {};

      const body = req.body as Record<string, never>;
      request.field = body.field;
      request.matrix = body.matrix;

      const result = await api.mirrorFields(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200).send(result.value);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/checkQuery',
    method: 'GET',
    handler: async function (req, res) {
      const request: ICheckQueryRequest = {};

      const query = req.query as Record<string, string>;
      if (typeof query['string'] === 'string') request.string = query['string'];
      if (typeof query['boolean'] === 'string') request.boolean = parseBoolean(query['boolean']);
      if (typeof query['double'] === 'string') request.double = parseFloat(query['double']);
      if (typeof query['int32'] === 'string') request.int32 = parseInt(query['int32'], 10);
      if (typeof query['int64'] === 'string') request.int64 = parseInt(query['int64'], 10);
      if (typeof query['decimal'] === 'string') request.decimal = parseFloat(query['decimal']);
      if (typeof query['enum'] === 'string') request.enum = query['enum'] as Answer;
      if (typeof query['datetime'] === 'string') request.datetime = query['datetime'];

      const result = await api.checkQuery(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/checkPath/:string/:boolean/:double/:int32/:int64/:decimal/:enum/:datetime',
    method: 'GET',
    handler: async function (req, res) {
      const request: ICheckPathRequest = {};

      const params = req.params as Record<string, string>;
      if (typeof params['string'] === 'string') request.string = params['string'];
      if (typeof params['boolean'] === 'string') request.boolean = parseBoolean(params['boolean']);
      if (typeof params['double'] === 'string') request.double = parseFloat(params['double']);
      if (typeof params['int32'] === 'string') request.int32 = parseInt(params['int32'], 10);
      if (typeof params['int64'] === 'string') request.int64 = parseInt(params['int64'], 10);
      if (typeof params['decimal'] === 'string') request.decimal = parseFloat(params['decimal']);
      if (typeof params['enum'] === 'string') request.enum = params['enum'] as Answer;
      if (typeof params['datetime'] === 'string') request.datetime = params['datetime'];

      const result = await api.checkPath(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/mirrorHeaders',
    method: 'GET',
    handler: async function (req, res) {
      const request: IMirrorHeadersRequest = {};

      const headers = req.headers as Record<string, string>;
      if (typeof headers['string'] === 'string') request.string = headers['string'];
      if (typeof headers['boolean'] === 'string') request.boolean = parseBoolean(headers['boolean']);
      if (typeof headers['double'] === 'string') request.double = parseFloat(headers['double']);
      if (typeof headers['int32'] === 'string') request.int32 = parseInt(headers['int32'], 10);
      if (typeof headers['int64'] === 'string') request.int64 = parseInt(headers['int64'], 10);
      if (typeof headers['decimal'] === 'string') request.decimal = parseFloat(headers['decimal']);
      if (typeof headers['enum'] === 'string') request.enum = headers['enum'] as Answer;
      if (typeof headers['datetime'] === 'string') request.datetime = headers['datetime'];

      const result = await api.mirrorHeaders(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.string != null) res.header('string', result.value.string);
        if (result.value.boolean != null) res.header('boolean', result.value.boolean);
        if (result.value.double != null) res.header('double', result.value.double);
        if (result.value.int32 != null) res.header('int32', result.value.int32);
        if (result.value.int64 != null) res.header('int64', result.value.int64);
        if (result.value.decimal != null) res.header('decimal', result.value.decimal);
        if (result.value.enum != null) res.header('enum', result.value.enum);
        if (result.value.datetime != null) res.header('datetime', result.value.datetime);

        res.status(200);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/mixed/:path',
    method: 'POST',
    handler: async function (req, res) {
      const request: IMixedRequest = {};

      const params = req.params as Record<string, string>;
      if (typeof params['path'] === 'string') request.path = params['path'];

      const query = req.query as Record<string, string>;
      if (typeof query['query'] === 'string') request.query = query['query'];

      const headers = req.headers as Record<string, string>;
      if (typeof headers['header'] === 'string') request.header = headers['header'];

      const body = req.body as Record<string, never>;
      request.normal = body.normal;

      const result = await api.mixed(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.header != null) res.header('header', result.value.header);

        if (result.value.body) {
          res.status(202).send(result.value.body);
          return;
        }

        if (result.value.empty) {
          res.status(204);
          return;
        }

        res.status(200).send(result.value);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/required',
    method: 'POST',
    handler: async function (req, res) {
      const request: IRequiredRequest = {};

      const query = req.query as Record<string, string>;
      if (typeof query['query'] === 'string') request.query = query['query'];

      const body = req.body as Record<string, never>;
      request.normal = body.normal;
      request.widget = body.widget;
      request.widgets = body.widgets;
      request.widgetMatrix = body.widgetMatrix;
      request.widgetResult = body.widgetResult;
      request.widgetResults = body.widgetResults;
      request.widgetMap = body.widgetMap;
      request.hasWidget = body.hasWidget;
      request.point = body.point;

      const result = await api.required(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        res.status(200).send(result.value);
        return;
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/mirrorBytes',
    method: 'POST',
    handler: async function (req, res) {
      const request: IMirrorBytesRequest = {};

      const headers = req.headers as Record<string, string>;
      if (typeof headers['content-type'] === 'string') request.type = headers['content-type'];

      request.content = req.body as never;

      const result = await api.mirrorBytes(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.type != null) res.header('Content-Type', result.value.type);

        if (result.value.content) {
          res.status(200).send(result.value.content);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/mirrorText',
    method: 'POST',
    handler: async function (req, res) {
      const request: IMirrorTextRequest = {};

      const headers = req.headers as Record<string, string>;
      if (typeof headers['content-type'] === 'string') request.type = headers['content-type'];

      request.content = req.body as never;

      const result = await api.mirrorText(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.type != null) res.header('Content-Type', result.value.type);

        if (result.value.content) {
          res.status(200).send(result.value.content);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });

  fastify.route({
    url: '/bodyTypes',
    method: 'POST',
    handler: async function (req, res) {
      const request: IBodyTypesRequest = {};

      request.content = req.body as never;

      const result = await api.bodyTypes(request);

      if (result.error) {
        const status = result.error.code && standardErrorCodes[result.error.code];
        res.status(status || 500).send(result.error);
        return;
      }

      if (result.value) {
        if (result.value.content) {
          res.status(200).send(result.value.content);
          return;
        }
      }

      throw new Error('Result must have an error or value.');
    }
  });
}

/** API for a Facility test server. */
export interface IConformanceApi {
  /** Gets API information. */
  getApiInfo(request: IGetApiInfoRequest, context?: unknown): Promise<IServiceResult<IGetApiInfoResponse>>;

  /** Gets widgets. */
  getWidgets(request: IGetWidgetsRequest, context?: unknown): Promise<IServiceResult<IGetWidgetsResponse>>;

  /** Creates a new widget. */
  createWidget(request: ICreateWidgetRequest, context?: unknown): Promise<IServiceResult<ICreateWidgetResponse>>;

  /** Gets the specified widget. */
  getWidget(request: IGetWidgetRequest, context?: unknown): Promise<IServiceResult<IGetWidgetResponse>>;

  /** Deletes the specified widget. */
  deleteWidget(request: IDeleteWidgetRequest, context?: unknown): Promise<IServiceResult<IDeleteWidgetResponse>>;

  /** Gets the specified widgets. */
  getWidgetBatch(request: IGetWidgetBatchRequest, context?: unknown): Promise<IServiceResult<IGetWidgetBatchResponse>>;

  mirrorFields(request: IMirrorFieldsRequest, context?: unknown): Promise<IServiceResult<IMirrorFieldsResponse>>;

  checkQuery(request: ICheckQueryRequest, context?: unknown): Promise<IServiceResult<ICheckQueryResponse>>;

  checkPath(request: ICheckPathRequest, context?: unknown): Promise<IServiceResult<ICheckPathResponse>>;

  mirrorHeaders(request: IMirrorHeadersRequest, context?: unknown): Promise<IServiceResult<IMirrorHeadersResponse>>;

  mixed(request: IMixedRequest, context?: unknown): Promise<IServiceResult<IMixedResponse>>;

  required(request: IRequiredRequest, context?: unknown): Promise<IServiceResult<IRequiredResponse>>;

  mirrorBytes(request: IMirrorBytesRequest, context?: unknown): Promise<IServiceResult<IMirrorBytesResponse>>;

  mirrorText(request: IMirrorTextRequest, context?: unknown): Promise<IServiceResult<IMirrorTextResponse>>;

  bodyTypes(request: IBodyTypesRequest, context?: unknown): Promise<IServiceResult<IBodyTypesResponse>>;
}

/** Request for GetApiInfo. */
export interface IGetApiInfoRequest {
}

/** Response for GetApiInfo. */
export interface IGetApiInfoResponse {
  /** The name of the service. */
  service?: string;

  /** The version of the service. */
  version?: string;
}

/** Request for GetWidgets. */
export interface IGetWidgetsRequest {
  /** The query. */
  query?: string;
}

/** Response for GetWidgets. */
export interface IGetWidgetsResponse {
  /** The widgets. */
  widgets?: IWidget[];
}

/** Request for CreateWidget. */
export interface ICreateWidgetRequest {
  /** The widget to create. */
  widget?: IWidget;
}

/** Response for CreateWidget. */
export interface ICreateWidgetResponse {
  /** The created widget. */
  widget?: IWidget;

  /** The URL of the created widget. */
  url?: string;

  /** The ETag of the created widget. */
  eTag?: string;
}

/** Request for GetWidget. */
export interface IGetWidgetRequest {
  /** The widget ID. */
  id?: number;

  /** Don't get the widget if it has this ETag. */
  ifNotETag?: string;
}

/** Response for GetWidget. */
export interface IGetWidgetResponse {
  /** The requested widget. */
  widget?: IWidget;

  /** The ETag of the widget. */
  eTag?: string;

  /** The widget still has the specified ETag. */
  notModified?: boolean;
}

/** Request for DeleteWidget. */
export interface IDeleteWidgetRequest {
  /** The widget ID. */
  id?: number;

  /** Don't delete the widget unless it has this ETag. */
  ifETag?: string;
}

/** Response for DeleteWidget. */
export interface IDeleteWidgetResponse {
  /** The widget was not found. */
  notFound?: boolean;

  /** The widget no longer has the specified ETag. */
  conflict?: boolean;
}

/** Request for GetWidgetBatch. */
export interface IGetWidgetBatchRequest {
  /** The IDs of the widgets to return. */
  ids?: number[];
}

/** Response for GetWidgetBatch. */
export interface IGetWidgetBatchResponse {
  /** The widget results. */
  results?: IServiceResult<IWidget>[];
}

/** Request for MirrorFields. */
export interface IMirrorFieldsRequest {
  field?: IAny;

  matrix?: number[][][];
}

/** Response for MirrorFields. */
export interface IMirrorFieldsResponse {
  field?: IAny;

  matrix?: number[][][];
}

/** Request for CheckQuery. */
export interface ICheckQueryRequest {
  string?: string;

  boolean?: boolean;

  double?: number;

  int32?: number;

  int64?: number;

  decimal?: number;

  enum?: Answer;

  datetime?: string;
}

/** Response for CheckQuery. */
export interface ICheckQueryResponse {
}

/** Request for CheckPath. */
export interface ICheckPathRequest {
  string?: string;

  boolean?: boolean;

  double?: number;

  int32?: number;

  int64?: number;

  decimal?: number;

  enum?: Answer;

  datetime?: string;
}

/** Response for CheckPath. */
export interface ICheckPathResponse {
}

/** Request for MirrorHeaders. */
export interface IMirrorHeadersRequest {
  string?: string;

  boolean?: boolean;

  double?: number;

  int32?: number;

  int64?: number;

  decimal?: number;

  enum?: Answer;

  datetime?: string;
}

/** Response for MirrorHeaders. */
export interface IMirrorHeadersResponse {
  string?: string;

  boolean?: boolean;

  double?: number;

  int32?: number;

  int64?: number;

  decimal?: number;

  enum?: Answer;

  datetime?: string;
}

/** Request for Mixed. */
export interface IMixedRequest {
  path?: string;

  query?: string;

  header?: string;

  normal?: string;
}

/** Response for Mixed. */
export interface IMixedResponse {
  header?: string;

  normal?: string;

  body?: { [name: string]: any };

  empty?: boolean;
}

/** Request for Required. */
export interface IRequiredRequest {
  query?: string;

  normal?: string;

  widget?: IWidget;

  widgets?: IWidget[];

  widgetMatrix?: IWidget[][];

  widgetResult?: IServiceResult<IWidget>;

  widgetResults?: IServiceResult<IWidget>[];

  widgetMap?: { [name: string]: IWidget };

  hasWidget?: IHasWidget;

  point?: number[];
}

/** Response for Required. */
export interface IRequiredResponse {
  normal?: string;
}

/** Request for MirrorBytes. */
export interface IMirrorBytesRequest {
  content?: string;

  type?: string;
}

/** Response for MirrorBytes. */
export interface IMirrorBytesResponse {
  content?: string;

  type?: string;
}

/** Request for MirrorText. */
export interface IMirrorTextRequest {
  content?: string;

  type?: string;
}

/** Response for MirrorText. */
export interface IMirrorTextResponse {
  content?: string;

  type?: string;
}

/** Request for BodyTypes. */
export interface IBodyTypesRequest {
  content?: string;
}

/** Response for BodyTypes. */
export interface IBodyTypesResponse {
  content?: string;
}

/** A widget. */
export interface IWidget {
  /** A unique identifier for the widget. */
  id?: number;

  /** The name of the widget. */
  name?: string;
}

export interface IAny {
  string?: string;

  boolean?: boolean;

  double?: number;

  int32?: number;

  int64?: number;

  decimal?: number;

  datetime?: string;

  bytes?: string;

  object?: { [name: string]: any };

  error?: IServiceError;

  data?: IAny;

  enum?: Answer;

  array?: IAnyArray;

  map?: IAnyMap;

  result?: IAnyResult;

  nullable?: IAnyNullable;
}

export interface IAnyArray {
  string?: string[];

  boolean?: boolean[];

  double?: number[];

  int32?: number[];

  int64?: number[];

  decimal?: number[];

  datetime?: string[];

  bytes?: string[];

  object?: { [name: string]: any }[];

  error?: IServiceError[];

  data?: IAny[];

  enum?: Answer[];

  array?: number[][];

  map?: { [name: string]: number }[];

  result?: IServiceResult<number>[];

  nullable?: (number | null)[];
}

export interface IAnyMap {
  string?: { [name: string]: string };

  boolean?: { [name: string]: boolean };

  double?: { [name: string]: number };

  int32?: { [name: string]: number };

  int64?: { [name: string]: number };

  decimal?: { [name: string]: number };

  datetime?: { [name: string]: string };

  bytes?: { [name: string]: string };

  object?: { [name: string]: { [name: string]: any } };

  error?: { [name: string]: IServiceError };

  data?: { [name: string]: IAny };

  enum?: { [name: string]: Answer };

  array?: { [name: string]: number[] };

  map?: { [name: string]: { [name: string]: number } };

  result?: { [name: string]: IServiceResult<number> };

  nullable?: { [name: string]: (number | null) };
}

export interface IAnyResult {
  string?: IServiceResult<string>;

  boolean?: IServiceResult<boolean>;

  double?: IServiceResult<number>;

  int32?: IServiceResult<number>;

  int64?: IServiceResult<number>;

  decimal?: IServiceResult<number>;

  datetime?: IServiceResult<string>;

  bytes?: IServiceResult<string>;

  object?: IServiceResult<{ [name: string]: any }>;

  error?: IServiceResult<IServiceError>;

  data?: IServiceResult<IAny>;

  enum?: IServiceResult<Answer>;

  array?: IServiceResult<number[]>;

  map?: IServiceResult<{ [name: string]: number }>;

  result?: IServiceResult<IServiceResult<number>>;

  nullable?: IServiceResult<(number | null)>;
}

export interface IAnyNullable {
  string?: (string | null);

  boolean?: (boolean | null);

  double?: (number | null);

  int32?: (number | null);

  int64?: (number | null);

  decimal?: (number | null);

  datetime?: (string | null);

  bytes?: (string | null);

  object?: ({ [name: string]: any } | null);

  error?: (IServiceError | null);

  data?: (IAny | null);

  enum?: (Answer | null);

  array?: (number[] | null);

  map?: ({ [name: string]: number } | null);

  result?: (IServiceResult<number> | null);
}

export interface IHasWidget {
  widget?: IWidget;
}

/** One of three answers. */
export enum Answer {
  /** Affirmative. */
  yes = 'yes',

  /** Negative. */
  no = 'no',

  /** Unknown. */
  maybe = 'maybe',
}

/** Custom errors. */
export enum ApiErrors {
  /** The user is not an administrator. */
  NotAdmin = 'NotAdmin',

  /** I'm "too" 😄! */
  TooHappy = 'TooHappy',
}
