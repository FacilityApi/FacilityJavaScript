// DO NOT EDIT: generated by fsdgenjs
/* eslint-disable */

import { HttpClientUtility, IServiceResult, IHttpClientOptions } from 'facility-core';
import { IConformanceApi, IGetApiInfoRequest, IGetApiInfoResponse, IGetWidgetsRequest, IGetWidgetsResponse, ICreateWidgetRequest, ICreateWidgetResponse, IGetWidgetRequest, IGetWidgetResponse, IDeleteWidgetRequest, IDeleteWidgetResponse, IGetWidgetBatchRequest, IGetWidgetBatchResponse, IMirrorFieldsRequest, IMirrorFieldsResponse, ICheckQueryRequest, ICheckQueryResponse, ICheckPathRequest, ICheckPathResponse, IMirrorHeadersRequest, IMirrorHeadersResponse, IMixedRequest, IMixedResponse, IRequiredRequest, IRequiredResponse, IMirrorBytesRequest, IMirrorBytesResponse, IMirrorTextRequest, IMirrorTextResponse, IBodyTypesRequest, IBodyTypesResponse, IWidget, IAny, IAnyArray, IAnyMap, IAnyResult, IAnyNullable, IHasWidget, Answer, ApiErrors } from './conformanceApiTypes';
export * from './conformanceApiTypes';

/** Provides access to ConformanceApi over HTTP via fetch. */
export function createHttpClient(options: IHttpClientOptions): IConformanceApi {
  return new ConformanceApiHttpClient(options);
}

const { fetchResponse, createResponseError, createRequiredRequestFieldError } = HttpClientUtility;
type IFetch = HttpClientUtility.IFetch;
type IFetchRequest = HttpClientUtility.IFetchRequest;

function parseBoolean(value: string | undefined) {
  if (typeof value === 'string') {
    const lowerValue = value.toLowerCase();
    if (lowerValue === 'true') {
      return true;
    }
    if (lowerValue === 'false') {
      return false;
    }
  }
  return undefined;
}

/** Provides access to ConformanceApi over HTTP via fetch. */
export class ConformanceApiHttpClient implements IConformanceApi {
  constructor({ fetch, baseUri }: IHttpClientOptions) {
    if (typeof fetch !== 'function') {
      throw new TypeError('fetch must be a function.');
    }
    if (typeof baseUri === 'undefined') {
      baseUri = '';
    }
    if (/[^\/]$/.test(baseUri)) {
      baseUri += '/';
    }
    this._fetch = fetch;
    this._baseUri = baseUri;
  }

  /** Gets API information. */
  public getApiInfo(request: IGetApiInfoRequest, context?: unknown): Promise<IServiceResult<IGetApiInfoResponse>> {
    const uri = '';
    const fetchRequest: IFetchRequest = {
      method: 'GET',
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IGetApiInfoResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = result.json as IGetApiInfoResponse | null;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IGetApiInfoResponse>;
        }
        return { value: value };
      });
  }

  /** Gets widgets. */
  public getWidgets(request: IGetWidgetsRequest, context?: unknown): Promise<IServiceResult<IGetWidgetsResponse>> {
    let uri = 'widgets';
    const query: string[] = [];
    request.query == null || query.push('q=' + encodeURIComponent(request.query));
    if (query.length) {
      uri = uri + '?' + query.join('&');
    }
    const fetchRequest: IFetchRequest = {
      method: 'GET',
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IGetWidgetsResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = result.json as IGetWidgetsResponse | null;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IGetWidgetsResponse>;
        }
        return { value: value };
      });
  }

  /** Creates a new widget. */
  public createWidget(request: ICreateWidgetRequest, context?: unknown): Promise<IServiceResult<ICreateWidgetResponse>> {
    const uri = 'widgets';
    if (!request.widget) {
      return Promise.resolve(createRequiredRequestFieldError('widget'));
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request.widget)
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: ICreateWidgetResponse | null = null;
        if (status === 201) {
          if (result.json) {
            value = { widget: result.json } as ICreateWidgetResponse;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<ICreateWidgetResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('Location');
        if (headerValue != null) {
          value.url = headerValue;
        }
        headerValue = result.response.headers.get('eTag');
        if (headerValue != null) {
          value.eTag = headerValue;
        }
        return { value: value };
      });
  }

  /** Gets the specified widget. */
  public getWidget(request: IGetWidgetRequest, context?: unknown): Promise<IServiceResult<IGetWidgetResponse>> {
    const uriPartId = request.id != null && request.id.toString();
    if (!uriPartId) {
      return Promise.resolve(createRequiredRequestFieldError('id'));
    }
    const uri = `widgets/${uriPartId}`;
    const fetchRequest: IFetchRequest = {
      method: 'GET',
      headers: {},
    };
    if (request.ifNotETag != null) {
      fetchRequest.headers!['If-None-Match'] = request.ifNotETag;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IGetWidgetResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = { widget: result.json } as IGetWidgetResponse;
          }
        }
        else if (status === 304) {
          value = { notModified: true };
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IGetWidgetResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('eTag');
        if (headerValue != null) {
          value.eTag = headerValue;
        }
        return { value: value };
      });
  }

  /** Deletes the specified widget. */
  public deleteWidget(request: IDeleteWidgetRequest, context?: unknown): Promise<IServiceResult<IDeleteWidgetResponse>> {
    const uriPartId = request.id != null && request.id.toString();
    if (!uriPartId) {
      return Promise.resolve(createRequiredRequestFieldError('id'));
    }
    const uri = `widgets/${uriPartId}`;
    const fetchRequest: IFetchRequest = {
      method: 'DELETE',
      headers: {},
    };
    if (request.ifETag != null) {
      fetchRequest.headers!['If-Match'] = request.ifETag;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IDeleteWidgetResponse | null = null;
        if (status === 204) {
          value = {};
        }
        else if (status === 404) {
          value = { notFound: true };
        }
        else if (status === 409) {
          value = { conflict: true };
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IDeleteWidgetResponse>;
        }
        return { value: value };
      });
  }

  /** Gets the specified widgets. */
  public getWidgetBatch(request: IGetWidgetBatchRequest, context?: unknown): Promise<IServiceResult<IGetWidgetBatchResponse>> {
    const uri = 'widgets/get';
    if (!request.ids) {
      return Promise.resolve(createRequiredRequestFieldError('ids'));
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request.ids)
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IGetWidgetBatchResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = { results: result.json } as IGetWidgetBatchResponse;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IGetWidgetBatchResponse>;
        }
        return { value: value };
      });
  }

  public mirrorFields(request: IMirrorFieldsRequest, context?: unknown): Promise<IServiceResult<IMirrorFieldsResponse>> {
    const uri = 'mirrorFields';
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IMirrorFieldsResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = result.json as IMirrorFieldsResponse | null;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IMirrorFieldsResponse>;
        }
        return { value: value };
      });
  }

  public checkQuery(request: ICheckQueryRequest, context?: unknown): Promise<IServiceResult<ICheckQueryResponse>> {
    let uri = 'checkQuery';
    const query: string[] = [];
    request.string == null || query.push('string=' + encodeURIComponent(request.string));
    request.boolean == null || query.push('boolean=' + request.boolean.toString());
    request.float == null || query.push('float=' + encodeURIComponent(request.float.toString()));
    request.double == null || query.push('double=' + encodeURIComponent(request.double.toString()));
    request.int32 == null || query.push('int32=' + request.int32.toString());
    request.int64 == null || query.push('int64=' + request.int64.toString());
    request.decimal == null || query.push('decimal=' + request.decimal.toString());
    request.enum == null || query.push('enum=' + request.enum);
    request.datetime == null || query.push('datetime=' + encodeURIComponent(request.datetime));
    if (query.length) {
      uri = uri + '?' + query.join('&');
    }
    const fetchRequest: IFetchRequest = {
      method: 'GET',
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: ICheckQueryResponse | null = null;
        if (status === 200) {
          value = {};
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<ICheckQueryResponse>;
        }
        return { value: value };
      });
  }

  public checkPath(request: ICheckPathRequest, context?: unknown): Promise<IServiceResult<ICheckPathResponse>> {
    const uriPartString = request.string != null && encodeURIComponent(request.string);
    if (!uriPartString) {
      return Promise.resolve(createRequiredRequestFieldError('string'));
    }
    const uriPartBoolean = request.boolean != null && request.boolean.toString();
    if (!uriPartBoolean) {
      return Promise.resolve(createRequiredRequestFieldError('boolean'));
    }
    const uriPartFloat = request.float != null && encodeURIComponent(request.float.toString());
    if (!uriPartFloat) {
      return Promise.resolve(createRequiredRequestFieldError('float'));
    }
    const uriPartDouble = request.double != null && encodeURIComponent(request.double.toString());
    if (!uriPartDouble) {
      return Promise.resolve(createRequiredRequestFieldError('double'));
    }
    const uriPartInt32 = request.int32 != null && request.int32.toString();
    if (!uriPartInt32) {
      return Promise.resolve(createRequiredRequestFieldError('int32'));
    }
    const uriPartInt64 = request.int64 != null && request.int64.toString();
    if (!uriPartInt64) {
      return Promise.resolve(createRequiredRequestFieldError('int64'));
    }
    const uriPartDecimal = request.decimal != null && request.decimal.toString();
    if (!uriPartDecimal) {
      return Promise.resolve(createRequiredRequestFieldError('decimal'));
    }
    const uriPartEnum = request.enum != null && request.enum;
    if (!uriPartEnum) {
      return Promise.resolve(createRequiredRequestFieldError('enum'));
    }
    const uriPartDatetime = request.datetime != null && encodeURIComponent(request.datetime);
    if (!uriPartDatetime) {
      return Promise.resolve(createRequiredRequestFieldError('datetime'));
    }
    const uri = `checkPath/${uriPartString}/${uriPartBoolean}/${uriPartFloat}/${uriPartDouble}/${uriPartInt32}/${uriPartInt64}/${uriPartDecimal}/${uriPartEnum}/${uriPartDatetime}`;
    const fetchRequest: IFetchRequest = {
      method: 'GET',
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: ICheckPathResponse | null = null;
        if (status === 200) {
          value = {};
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<ICheckPathResponse>;
        }
        return { value: value };
      });
  }

  public mirrorHeaders(request: IMirrorHeadersRequest, context?: unknown): Promise<IServiceResult<IMirrorHeadersResponse>> {
    const uri = 'mirrorHeaders';
    const fetchRequest: IFetchRequest = {
      method: 'GET',
      headers: {},
    };
    if (request.string != null) {
      fetchRequest.headers!['string'] = request.string;
    }
    if (request.boolean != null) {
      fetchRequest.headers!['boolean'] = request.boolean.toString();
    }
    if (request.float != null) {
      fetchRequest.headers!['float'] = request.float.toString();
    }
    if (request.double != null) {
      fetchRequest.headers!['double'] = request.double.toString();
    }
    if (request.int32 != null) {
      fetchRequest.headers!['int32'] = request.int32.toString();
    }
    if (request.int64 != null) {
      fetchRequest.headers!['int64'] = request.int64.toString();
    }
    if (request.decimal != null) {
      fetchRequest.headers!['decimal'] = request.decimal.toString();
    }
    if (request.enum != null) {
      fetchRequest.headers!['enum'] = request.enum;
    }
    if (request.datetime != null) {
      fetchRequest.headers!['datetime'] = request.datetime;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IMirrorHeadersResponse | null = null;
        if (status === 200) {
          value = {};
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IMirrorHeadersResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('string');
        if (headerValue != null) {
          value.string = headerValue;
        }
        headerValue = result.response.headers.get('boolean');
        if (headerValue != null) {
          value.boolean = parseBoolean(headerValue);
        }
        headerValue = result.response.headers.get('float');
        if (headerValue != null) {
          value.float = parseFloat(headerValue);
        }
        headerValue = result.response.headers.get('double');
        if (headerValue != null) {
          value.double = parseFloat(headerValue);
        }
        headerValue = result.response.headers.get('int32');
        if (headerValue != null) {
          value.int32 = parseInt(headerValue, 10);
        }
        headerValue = result.response.headers.get('int64');
        if (headerValue != null) {
          value.int64 = parseInt(headerValue, 10);
        }
        headerValue = result.response.headers.get('decimal');
        if (headerValue != null) {
          value.decimal = parseFloat(headerValue);
        }
        headerValue = result.response.headers.get('enum');
        if (headerValue != null) {
          value.enum = headerValue as Answer;
        }
        headerValue = result.response.headers.get('datetime');
        if (headerValue != null) {
          value.datetime = headerValue;
        }
        return { value: value };
      });
  }

  public mixed(request: IMixedRequest, context?: unknown): Promise<IServiceResult<IMixedResponse>> {
    const uriPartPath = request.path != null && encodeURIComponent(request.path);
    if (!uriPartPath) {
      return Promise.resolve(createRequiredRequestFieldError('path'));
    }
    let uri = `mixed/${uriPartPath}`;
    const query: string[] = [];
    request.query == null || query.push('query=' + encodeURIComponent(request.query));
    if (query.length) {
      uri = uri + '?' + query.join('&');
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        normal: request.normal
      })
    };
    if (request.header != null) {
      fetchRequest.headers!['header'] = request.header;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IMixedResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = result.json as IMixedResponse | null;
          }
        }
        else if (status === 202) {
          if (result.json) {
            value = { body: result.json } as IMixedResponse;
          }
        }
        else if (status === 204) {
          value = { empty: true };
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IMixedResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('header');
        if (headerValue != null) {
          value.header = headerValue;
        }
        return { value: value };
      });
  }

  public required(request: IRequiredRequest, context?: unknown): Promise<IServiceResult<IRequiredResponse>> {
    let uri = 'required';
    const query: string[] = [];
    request.query == null || query.push('query=' + encodeURIComponent(request.query));
    if (query.length) {
      uri = uri + '?' + query.join('&');
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        normal: request.normal,
        widget: request.widget,
        widgets: request.widgets,
        widgetMatrix: request.widgetMatrix,
        widgetResult: request.widgetResult,
        widgetResults: request.widgetResults,
        widgetMap: request.widgetMap,
        hasWidget: request.hasWidget,
        point: request.point
      })
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IRequiredResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = result.json as IRequiredResponse | null;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IRequiredResponse>;
        }
        return { value: value };
      });
  }

  public mirrorBytes(request: IMirrorBytesRequest, context?: unknown): Promise<IServiceResult<IMirrorBytesResponse>> {
    const uri = 'mirrorBytes';
    if (!request.content) {
      return Promise.resolve(createRequiredRequestFieldError('content'));
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request.content)
    };
    if (request.type != null) {
      fetchRequest.headers!['Content-Type'] = request.type;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IMirrorBytesResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = { content: result.json } as IMirrorBytesResponse;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IMirrorBytesResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('Content-Type');
        if (headerValue != null) {
          value.type = headerValue;
        }
        return { value: value };
      });
  }

  public mirrorText(request: IMirrorTextRequest, context?: unknown): Promise<IServiceResult<IMirrorTextResponse>> {
    const uri = 'mirrorText';
    if (!request.content) {
      return Promise.resolve(createRequiredRequestFieldError('content'));
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request.content)
    };
    if (request.type != null) {
      fetchRequest.headers!['Content-Type'] = request.type;
    }
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IMirrorTextResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = { content: result.json } as IMirrorTextResponse;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IMirrorTextResponse>;
        }
        let headerValue: string | null | undefined;
        headerValue = result.response.headers.get('Content-Type');
        if (headerValue != null) {
          value.type = headerValue;
        }
        return { value: value };
      });
  }

  public bodyTypes(request: IBodyTypesRequest, context?: unknown): Promise<IServiceResult<IBodyTypesResponse>> {
    const uri = 'bodyTypes';
    if (!request.content) {
      return Promise.resolve(createRequiredRequestFieldError('content'));
    }
    const fetchRequest: IFetchRequest = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request.content)
    };
    return fetchResponse(this._fetch, this._baseUri + uri, fetchRequest, context)
      .then(result => {
        const status = result.response.status;
        let value: IBodyTypesResponse | null = null;
        if (status === 200) {
          if (result.json) {
            value = { content: result.json } as IBodyTypesResponse;
          }
        }
        if (!value) {
          return createResponseError(status, result.json) as IServiceResult<IBodyTypesResponse>;
        }
        return { value: value };
      });
  }

  private _fetch: IFetch;
  private _baseUri: string;
}
