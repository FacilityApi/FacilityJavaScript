// DO NOT EDIT: generated by fsdgenjs
'use strict';

import * as bodyParser from 'body-parser';
import * as express from 'express';
import { } from 'facility-core';

const standardErrorCodes = {
  'notModified': 304,
  'invalidRequest': 400,
  'notAuthenticated': 401,
  'notAuthorized': 403,
  'notFound': 404,
  'conflict': 409,
  'requestTooLarge': 413,
  'tooManyRequests': 429,
  'internalError': 500,
  'serviceUnavailable': 503,
};

export function createApp(service) {
  const app = express();
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: true }));

  /** Gets widgets. */
  app.get('/widgets', function (req, res, next) {
    const request = {};
    if (req.query['q'] != null) {
      request.query = req.query['q'];
    }
    if (req.query['limit'] != null) {
      request.limit = parseInt(req.query['limit'], 10);
    }
    if (req.query['sort'] != null) {
      request.sort = req.query['sort'];
    }
    if (req.query['desc'] != null) {
      request.desc = req.query['desc'] === 'true';
    }
    if (req.query['maxWeight'] != null) {
      request.maxWeight = parseFloat(req.query['maxWeight']);
    }
    if (req.query['minPrice'] != null) {
      request.minPrice = parseFloat(req.query['minPrice']);
    }

    return service.getWidgets(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.job) {
            res.status(202).send(result.value.job);
          }
          res.status(200).send(result.value);
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Creates a new widget. */
  app.post('/widgets', function (req, res, next) {
    const request = {};

    return service.createWidget(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.widget) {
            res.status(201).send(result.value.widget);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Gets the specified widget. */
  app.get('/widgets/:id', function (req, res, next) {
    const request = {};
    request.id = req.params.id;

    return service.getWidget(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.widget) {
            res.status(200).send(result.value.widget);
          }
          if (result.value.notModified) {
            res.sendStatus(304);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Deletes the specified widget. */
  app.delete('/widgets/:id', function (req, res, next) {
    const request = {};
    request.id = req.params.id;

    return service.deleteWidget(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          throw new Error('TODO');
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Edits widget. */
  app.post('/widgets/:id', function (req, res, next) {
    const request = {};
    request.id = req.params.id;

    return service.editWidget(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.widget) {
            res.status(200).send(result.value.widget);
          }
          if (result.value.job) {
            res.status(202).send(result.value.job);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Gets the specified widgets. */
  app.post('/widgets/get', function (req, res, next) {
    const request = {};

    return service.getWidgetBatch(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.results) {
            res.status(200).send(result.value.results);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /**
   * Gets the widget weight.
   * @deprecated
   */
  app.get('/widgets/:id/weight', function (req, res, next) {
    const request = {};
    request.id = req.params.id;

    return service.getWidgetWeight(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          res.status(200).send(result.value);
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Gets a widget preference. */
  app.get('/prefs/:key', function (req, res, next) {
    const request = {};
    request.key = req.params.key;

    return service.getPreference(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.value) {
            res.status(200).send(result.value.value);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Sets a widget preference. */
  app.put('/prefs/:key', function (req, res, next) {
    const request = {};
    request.key = req.params.key;

    return service.setPreference(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          if (result.value.value) {
            res.status(200).send(result.value.value);
          }
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Gets service info. */
  app.get('/', function (req, res, next) {
    const request = {};

    return service.getInfo(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          res.status(200).send(result.value);
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  /** Demonstrates the default HTTP behavior. */
  app.post('/notRestful', function (req, res, next) {
    const request = {};

    return service.notRestful(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          throw new Error('TODO');
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  app.post('/kitchen', function (req, res, next) {
    const request = {};

    return service.kitchen(request)
      .then(result => {
        if (result.error) {
          const status = result.error.code && standardErrorCodes[result.error.code] || 500;
          res.status(status).send(result.error.details);
        } else if (result.value) {
          throw new Error('TODO');
        } else {
          throw new Error('Result must have an error or value.');
        }
      })
      .catch(next);
  });

  return app;
}
