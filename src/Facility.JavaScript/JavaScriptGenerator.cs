using System;
using System.Linq;
using System.Net;
using Facility.Definition;
using Facility.Definition.CodeGen;
using Facility.Definition.Http;

namespace Facility.JavaScript
{
	/// <summary>
	/// Generates JavaScript and TypeScript.
	/// </summary>
	public sealed class JavaScriptGenerator : CodeGenerator
	{
		/// <summary>
		/// The name of the module (optional).
		/// </summary>
		public string ModuleName { get; set; }

		/// <summary>
		/// True to generate TypeScript.
		/// </summary>
		public bool TypeScript { get; set; }

		/// <summary>
		/// Generates the C# output.
		/// </summary>
		protected override CodeGenOutput GenerateOutputCore(ServiceInfo service)
		{
			var httpServiceInfo = new HttpServiceInfo(service);

			string moduleName = ModuleName ?? service.Name;
			string capModuleName = CodeGenUtility.Capitalize(moduleName);

			return new CodeGenOutput(CreateNamedText(moduleName + (TypeScript ? ".ts" : ".js"), code =>
			{
				code.WriteLine($"// DO NOT EDIT: generated by {GeneratorName}");

				if (!TypeScript)
					code.WriteLine("'use strict';");

				code.WriteLine();
				code.WriteLine("import { HttpClientUtility" + IfTypeScript(", IServiceResult, IServiceError, IHttpClientOptions") + " } from 'facility-core';");

				code.WriteLine();
				code.WriteLine($"/** Provides access to {capModuleName} over HTTP via fetch. */");
				using (code.Block("export function createHttpClient({ fetch, baseUri }" + IfTypeScript(": IHttpClientOptions") + $"): I{capModuleName} {{", "}"))
					code.WriteLine($"return new {capModuleName}HttpClient(fetch, baseUri);");

				if (TypeScript)
				{
					code.WriteLine();
					code.WriteLine($"/** {service.Summary} */");
					using (code.Block($"export interface I{capModuleName} {{", "}"))
					{
						foreach (var httpMethodInfo in httpServiceInfo.Methods)
						{
							string methodName = httpMethodInfo.ServiceMethod.Name;
							string capMethodName = CodeGenUtility.Capitalize(methodName);
							code.WriteLine($"/** {httpMethodInfo.ServiceMethod.Summary} */");
							code.WriteLine($"{methodName}(request: I{capMethodName}Request): Promise<IServiceResult<I{capMethodName}Response>>;");
						}
					}

					foreach (var methodInfo in service.Methods)
					{
						WriteDto(code, new ServiceDtoInfo(
							name: $"{CodeGenUtility.Capitalize(methodInfo.Name)}Request",
							fields: methodInfo.RequestFields,
							summary: $"Request for {CodeGenUtility.Capitalize(methodInfo.Name)}.",
							position: methodInfo.Position), service);

						WriteDto(code, new ServiceDtoInfo(
							name: $"{CodeGenUtility.Capitalize(methodInfo.Name)}Response",
							fields: methodInfo.ResponseFields,
							summary: $"Response for {CodeGenUtility.Capitalize(methodInfo.Name)}.",
							position: methodInfo.Position), service);
					}

					foreach (var dtoInfo in service.Dtos)
						WriteDto(code, dtoInfo, service);
				}

				code.WriteLine();
				code.WriteLine("const { fetchJson, createResponseError } = HttpClientUtility;");
				if (TypeScript)
				{
					code.WriteLine("type IFetch = HttpClientUtility.IFetch;");
					code.WriteLine("type IFetchRequest = HttpClientUtility.IFetchRequest;");
				}

				code.WriteLine();
				using (code.Block($"class {capModuleName}HttpClient" + IfTypeScript($" implements I{capModuleName}") + " {", "}"))
				{
					using (code.Block("constructor(fetch" + IfTypeScript(": IFetch") + ", baseUri" + IfTypeScript(": string") + ") {", "}"))
					{
						using (code.Block("if (typeof fetch !== 'function') {", "}"))
							code.WriteLine("throw new TypeError('fetch must be a function.');");
						using (code.Block("if (typeof baseUri === 'undefined') {", "}"))
							code.WriteLine($"baseUri = '{httpServiceInfo.Url ?? ""}';");
						using (code.Block(@"if (/[^\/]$/.test(baseUri)) {", "}"))
							code.WriteLine("baseUri += '/';");

						code.WriteLine("this._fetch = fetch;");
						code.WriteLine("this._baseUri = baseUri;");
					}

					foreach (var httpMethodInfo in httpServiceInfo.Methods)
					{
						string methodName = httpMethodInfo.ServiceMethod.Name;
						string capMethodName = CodeGenUtility.Capitalize(methodName);

						code.WriteLine($"/** {httpMethodInfo.ServiceMethod.Summary} */");
						using (code.Block(IfTypeScript("public ") + $"{methodName}(request" + IfTypeScript($": I{capMethodName}Request") + ")" + IfTypeScript($": Promise<IServiceResult<I{capMethodName}Response>>") + " {", "}"))
						{
							bool hasPathFields = httpMethodInfo.PathFields.Count != 0;
							bool hasQueryFields = httpMethodInfo.QueryFields.Count != 0;

							string jsUriDelim = hasPathFields ? "`" : "'";
							string jsUri = jsUriDelim + httpMethodInfo.Path + jsUriDelim;
							foreach (var httpPathField in httpMethodInfo.PathFields)
								jsUri = jsUri.Replace("{" + httpPathField.ServiceField.Name + "}", "{encodeURIComponent(request." + httpPathField.ServiceField.Name + ")}");
							code.WriteLine((hasQueryFields ? "var" : "const") + $" uri = {jsUri};");

							if (httpMethodInfo.QueryFields.Count != 0)
							{
								code.WriteLine("const query" + IfTypeScript(": string[]") + " = [];");
								foreach (var httpQueryField in httpMethodInfo.QueryFields)
									code.WriteLine($"request.{httpQueryField.ServiceField.Name} == null || query.push('{httpQueryField.Name}=' + encodeURIComponent(request.{httpQueryField.ServiceField.Name}));");
								using (code.Block("if (query.length) {", "}"))
									code.WriteLine("uri = uri + '?' + query.join('&');");
							}

							code.WriteLine("const body = JSON.stringify(request);");
							using (code.Block("const fetchRequest" + IfTypeScript(": IFetchRequest") + " = {", "};"))
							{
								code.WriteLine($"method: '{httpMethodInfo.Method}',");
								code.WriteLine("headers: { 'Content-Type': 'application/json' },");

								if (httpMethodInfo.RequestBodyField != null)
								{
									code.WriteLine("body: request." + httpMethodInfo.RequestBodyField.ServiceField.Name);
								}
								else if (httpMethodInfo.RequestNormalFields.Count == 0)
								{
									code.WriteLine("body: null");
								}
								else if (httpMethodInfo.ServiceMethod.RequestFields.Count == httpMethodInfo.RequestNormalFields.Count)
								{
									code.WriteLine("body: body");
								}
								else
								{
									using (code.Block("body: {", "}"))
									{
										for (int httpFieldIndex = 0; httpFieldIndex < httpMethodInfo.RequestNormalFields.Count; httpFieldIndex++)
										{
											var httpFieldInfo = httpMethodInfo.RequestNormalFields[httpFieldIndex];
											bool isLastField = httpFieldIndex == httpMethodInfo.RequestNormalFields.Count - 1;
											string fieldName = httpFieldInfo.ServiceField.Name;
											code.WriteLine(fieldName + ": request." + fieldName + (isLastField ? "" : ","));
										}
									}
								}
							}

							code.WriteLine("return fetchJson(this._fetch, this._baseUri + uri, fetchRequest)");
							using (code.Indent())
							using (code.Block(".then(result => {", "});"))
							{
								code.WriteLine("const status = result.response.status;");

								var validResponses = httpMethodInfo.ValidResponses;
								foreach (var validResponse in validResponses)
								{
									if (validResponse.StatusCode == HttpStatusCode.NoContent && validResponses.All(x => x.StatusCode != HttpStatusCode.OK))
										code.WriteLine("if (status === 200 || status === 204) {");
									else
										code.WriteLine($"if (status === {(int) validResponse.StatusCode}) {{");

									string responseValueType = IfTypeScript($" as I{capMethodName}Response");
									using (code.Indent())
									{
										var bodyField = validResponse.BodyField;
										if (bodyField != null)
										{
											string responseBodyFieldName = bodyField.ServiceField.Name;

											var bodyFieldType = service.GetFieldType(bodyField.ServiceField);
											if (bodyFieldType.Kind == ServiceTypeKind.Boolean)
											{
												code.WriteLine($"return {{ value: {{ {responseBodyFieldName}: true }}{responseValueType} }};");
											}
											else
											{
												if (bodyFieldType.Dto.Fields.Count != 0)
													code.WriteLine($"return {{ value: {{ {responseBodyFieldName}: result.json }}{responseValueType} }};");
												else
													code.WriteLine($"return {{ value: {{ {responseBodyFieldName}: {{}} }}{responseValueType} }};");
											}
										}
										else
										{
											if (validResponse.NormalFields.Count != 0)
												code.WriteLine($"return {{ value: result.json{responseValueType} }};");
											else
												code.WriteLine($"return {{ value: {{}}{responseValueType} }};");
										}
									}
									code.WriteLine("}");
								}

								code.WriteLine("return createResponseError(status, result.json)" + IfTypeScript($" as IServiceResult<I{capMethodName}Response>") + ";");
							}
						}
					}

					code.WriteLine("private _fetch" + IfTypeScript(": IFetch") + ";");
					code.WriteLine("private _baseUri" + IfTypeScript(": string") + ";");
				}
			}));
		}

		private void WriteDto(CodeWriter code, ServiceDtoInfo dtoInfo, ServiceInfo service)
		{
			code.WriteLine();
			code.WriteLine($"/** {dtoInfo.Summary} */");
			using (code.Block($"export interface I{CodeGenUtility.Capitalize(dtoInfo.Name)} {{", "}"))
			{
				foreach (var fieldInfo in dtoInfo.Fields)
				{
					code.WriteLine($"/** {fieldInfo.Summary} */");
					code.WriteLine($"{fieldInfo.Name}?: {RenderFieldType(service.GetFieldType(fieldInfo))};");
				}
			}
		}

		private string IfTypeScript(string value)
		{
			return TypeScript ? value : "";
		}

		private string RenderFieldType(ServiceTypeInfo fieldType)
		{
			switch (fieldType.Kind)
			{
			case ServiceTypeKind.String:
			case ServiceTypeKind.Bytes:
			case ServiceTypeKind.Enum:
				return "string";
			case ServiceTypeKind.Boolean:
				return "boolean";
			case ServiceTypeKind.Double:
			case ServiceTypeKind.Int32:
			case ServiceTypeKind.Int64:
				return "number";
			case ServiceTypeKind.Object:
			case ServiceTypeKind.Map:
				return "any";
			case ServiceTypeKind.Error:
				return "IServiceError";
			case ServiceTypeKind.Dto:
				return $"I{CodeGenUtility.Capitalize(fieldType.Dto.Name)}";
			case ServiceTypeKind.Result:
				return $"IServiceResult<{RenderFieldType(fieldType.ValueType)}>";
			case ServiceTypeKind.Array:
				return $"{RenderFieldType(fieldType.ValueType)}[]";
			default:
				throw new NotSupportedException("Unknown field type " + fieldType.Kind);
			}
		}
	}
}
